"""
SQLAlchemy models for note artifacts.

Artifacts are extracted content blocks (tables, images, code) from notes
that require special processing and storage.
"""

from datetime import datetime, timezone
from typing import Optional
from uuid import uuid4

from sqlalchemy import (
    Column,
    DateTime,
    Enum,
    ForeignKey,
    Index,
    Integer,
    String,
    Text,
    func,
)
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.orm import relationship

from synaptiq.infrastructure.database import Base


def utc_now():
    """Get current UTC datetime."""
    return datetime.now(timezone.utc)


def generate_uuid():
    """Generate a new UUID string."""
    return str(uuid4())


class NoteArtifact(Base):
    """
    Base artifact extracted from a note.
    
    Represents a non-text content block (table, image, code, diagram)
    that has been processed for knowledge extraction.
    """
    __tablename__ = "note_artifacts"
    
    id = Column(
        UUID(as_uuid=False),
        primary_key=True,
        default=generate_uuid,
    )
    note_id = Column(
        UUID(as_uuid=False),
        ForeignKey("notes.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    user_id = Column(
        String(36),
        nullable=False,
        index=True,
    )
    
    # Artifact type: table, image, code, mermaid
    artifact_type = Column(
        String(20),
        nullable=False,
        index=True,
    )
    
    # Position tracking
    position_in_source = Column(
        Integer,
        nullable=False,
        doc="Character offset where artifact starts in source note",
    )
    
    # Context from surrounding text
    context_before = Column(
        Text,
        nullable=True,
        doc="Text before this artifact (~200 chars)",
    )
    context_after = Column(
        Text,
        nullable=True,
        doc="Text after this artifact (~200 chars)",
    )
    
    # Raw content as found in note
    raw_content = Column(
        Text,
        nullable=False,
        doc="Original content (markdown table, image URL, code block, etc.)",
    )
    
    # LLM-generated description for semantic search
    description = Column(
        Text,
        nullable=True,
        doc="Natural language description generated by LLM",
    )
    
    # Combined text used for embedding
    combined_text_for_embedding = Column(
        Text,
        nullable=True,
        doc="Context + description combined for embedding generation",
    )
    
    # Qdrant point ID for the artifact embedding
    qdrant_point_id = Column(
        UUID(as_uuid=False),
        nullable=True,
        doc="Reference to embedding in Qdrant",
    )
    
    # Processing status
    processing_status = Column(
        String(20),
        default="pending",
        doc="pending, processing, completed, failed",
    )
    processing_error = Column(
        Text,
        nullable=True,
    )
    
    # Timestamps
    created_at = Column(
        DateTime(timezone=True),
        default=utc_now,
        server_default=func.now(),
        nullable=False,
    )
    updated_at = Column(
        DateTime(timezone=True),
        default=utc_now,
        onupdate=utc_now,
        server_default=func.now(),
        nullable=False,
    )
    processed_at = Column(
        DateTime(timezone=True),
        nullable=True,
    )
    
    # Indexes
    __table_args__ = (
        Index("ix_note_artifacts_note_type", "note_id", "artifact_type"),
        Index("ix_note_artifacts_user_type", "user_id", "artifact_type"),
    )
    
    def __repr__(self):
        return f"<NoteArtifact(id={self.id}, type={self.artifact_type}, note={self.note_id})>"


class TableArtifact(Base):
    """
    Structured table data extracted from a note artifact.
    
    Stores both the structured representation (for precise queries)
    and LLM-generated analysis (for semantic search).
    """
    __tablename__ = "table_artifacts"
    
    id = Column(
        UUID(as_uuid=False),
        primary_key=True,
        default=generate_uuid,
    )
    artifact_id = Column(
        UUID(as_uuid=False),
        ForeignKey("note_artifacts.id", ondelete="CASCADE"),
        nullable=False,
        unique=True,
    )
    
    # Original markdown/HTML
    raw_markdown = Column(
        Text,
        nullable=False,
    )
    
    # Parsed structure: {headers: [], rows: [{col: value, ...}], row_count, col_count}
    structured_json = Column(
        JSONB,
        nullable=True,
        doc="Parsed table structure with headers and rows",
    )
    
    # Row-level facts extracted by LLM
    # ["GPT-4 has 1.7T parameters", "Claude has 200K context window", ...]
    row_facts = Column(
        JSONB,
        default=list,
        doc="Individual facts extracted from each row",
    )
    
    # Qdrant point IDs for row fact embeddings
    row_fact_qdrant_ids = Column(
        JSONB,
        default=list,
        doc="Qdrant point IDs for individual row fact embeddings",
    )
    
    # Statistics
    row_count = Column(Integer, nullable=True)
    column_count = Column(Integer, nullable=True)
    
    # Relationship
    artifact = relationship(
        "NoteArtifact",
        backref="table_data",
        foreign_keys=[artifact_id],
    )
    
    def __repr__(self):
        return f"<TableArtifact(id={self.id}, rows={self.row_count}, cols={self.column_count})>"


class ImageArtifact(Base):
    """
    Image metadata and analysis from a note artifact.
    
    Stores S3 reference and vision model analysis.
    """
    __tablename__ = "image_artifacts"
    
    id = Column(
        UUID(as_uuid=False),
        primary_key=True,
        default=generate_uuid,
    )
    artifact_id = Column(
        UUID(as_uuid=False),
        ForeignKey("note_artifacts.id", ondelete="CASCADE"),
        nullable=False,
        unique=True,
    )
    
    # S3 storage
    s3_key = Column(
        String(500),
        nullable=True,
        doc="S3 object key for stored image",
    )
    s3_url = Column(
        String(1000),
        nullable=True,
        doc="S3 URL for image access",
    )
    
    # Original source
    original_url = Column(
        String(2000),
        nullable=True,
        doc="Original URL if image was external",
    )
    
    # Image classification
    image_type = Column(
        String(50),
        nullable=True,
        doc="diagram, screenshot, chart, photo, etc.",
    )
    
    # Vision model extraction
    components = Column(
        JSONB,
        default=list,
        doc="Extracted components/entities from image",
    )
    relationships = Column(
        JSONB,
        default=list,
        doc="Relationships between components (for diagrams)",
    )
    ocr_text = Column(
        Text,
        nullable=True,
        doc="OCR-extracted text from screenshots",
    )
    data_points = Column(
        JSONB,
        nullable=True,
        doc="Extracted data points (for charts)",
    )
    
    # Image metadata
    width = Column(Integer, nullable=True)
    height = Column(Integer, nullable=True)
    format = Column(String(20), nullable=True, doc="png, jpg, svg, etc.")
    size_bytes = Column(Integer, nullable=True)
    
    # Relationship
    artifact = relationship(
        "NoteArtifact",
        backref="image_data",
        foreign_keys=[artifact_id],
    )
    
    def __repr__(self):
        return f"<ImageArtifact(id={self.id}, type={self.image_type})>"


class CodeArtifact(Base):
    """
    Code block analysis from a note artifact.
    
    Stores parsed code information and LLM explanation.
    """
    __tablename__ = "code_artifacts"
    
    id = Column(
        UUID(as_uuid=False),
        primary_key=True,
        default=generate_uuid,
    )
    artifact_id = Column(
        UUID(as_uuid=False),
        ForeignKey("note_artifacts.id", ondelete="CASCADE"),
        nullable=False,
        unique=True,
    )
    
    # Code content
    language = Column(
        String(50),
        nullable=True,
        doc="Programming language (python, javascript, etc.)",
    )
    raw_code = Column(
        Text,
        nullable=False,
    )
    
    # LLM-generated explanation
    explanation = Column(
        Text,
        nullable=True,
        doc="Natural language explanation of code",
    )
    
    # Extracted concepts (function names, imports, patterns)
    extracted_concepts = Column(
        JSONB,
        default=list,
        doc="Function names, class names, libraries, patterns",
    )
    
    # For mermaid diagrams: parsed structure
    is_mermaid = Column(
        Integer,
        default=0,
        doc="1 if this is a mermaid diagram",
    )
    mermaid_type = Column(
        String(50),
        nullable=True,
        doc="flowchart, sequence, class, etc.",
    )
    mermaid_components = Column(
        JSONB,
        default=list,
        doc="Nodes/entities in the diagram",
    )
    mermaid_relationships = Column(
        JSONB,
        default=list,
        doc="Edges/relationships in the diagram",
    )
    
    # Relationship
    artifact = relationship(
        "NoteArtifact",
        backref="code_data",
        foreign_keys=[artifact_id],
    )
    
    def __repr__(self):
        return f"<CodeArtifact(id={self.id}, lang={self.language})>"
